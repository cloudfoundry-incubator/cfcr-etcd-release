#!/bin/bash

set -euo pipefail
source /var/vcap/jobs/etcd/bin/utils.sh

etcdctl="/var/vcap/jobs/etcd/bin/etcdctl"

# We support transitioning to this etcd release from an existing 1 node
# cluster. This block checks the peer url and updates it to the correct DNS
# address. This covers upgrading from non-alias'd clusters to alias'd clusters.

update_peer_url_to_correct_dns_address() {
  export ETCDCTL_API=3
  if ! $etcdctl member list | grep "${etcd_peer_address}"; then
    member_id="$($etcdctl member list | grep "<%= spec.id %>" | cut -d',' -f1)"

    echo "Updating Member (${member_id}) peer url"

    $etcdctl member update "${member_id}" --peer-urls "${etcd_peer_address}"
  fi
}

setup_users_auth() {
  export ETCDCTL_API=2
  <% if_p('users') do |users| %>
  <% users.each do |user| %>
  username="<%= user["name"] %>"
  password="<%= user["password"] %>"
  ## Root user is first parsed
    <% if user["name"] == "root" %>
  echo "Set up user root"
  export ROOT_PASSWORD="$password"
  if [ -z "$($etcdctl --username root:$ROOT_PASSWORD user get root)" ]; then
    echo "$password" | $etcdctl --username root:$ROOT_PASSWORD user add root
  fi
    <% else %>
  ## if it's ordinary user
  echo "Set up user: $username"
  role="${username}-role"

  ## add user
  if [ -z "$($etcdctl --username root:$ROOT_PASSWORD user get $username)" ]; then
    echo "$password" | $etcdctl --username root:$ROOT_PASSWORD user add $username
  fi
  ## add role
  if [ -z "$($etcdctl --username root:$ROOT_PASSWORD role get $role)" ]; then
    $etcdctl --username root:$ROOT_PASSWORD role add $role
  fi

  ## grant read permission
      <% if user["permissions"]["read"] != nil %>
        <% user["permissions"]["read"].each do |read_path| %>
  path="<%= read_path %>"
  read_regex=".*KV Read:.*$path.*KV Write:.*"
  if ! [[ $($etcdctl --username root:$ROOT_PASSWORD role get $role) =~ $read_regex ]]; then
    $etcdctl --username root:$ROOT_PASSWORD role grant $role --read --path "$path"
  fi
        <% end %>
      <% end %>

  ## grant write permission
      <% if user["permissions"]["write"] != nil %>
        <% user["permissions"]["write"].each do |write_path| %>
  path="<%= write_path %>"
  write_regex=".*KV Write:.*$path.*"
  if ! [[ $($etcdctl --username root:$ROOT_PASSWORD role get $role) =~ $write_regex ]]; then
    $etcdctl --username root:$ROOT_PASSWORD role grant $role --write --path "$path"
  fi
        <% end %>
      <% end %>

  ## bind role to user
  role_regex="Roles:.*$role"
  if ! [[ "$($etcdctl --username root:$ROOT_PASSWORD user get $username)" =~ $role_regex ]]; then
    $etcdctl --username root:$ROOT_PASSWORD user grant $username --roles $role
  fi

  $etcdctl --username root:$ROOT_PASSWORD user get $username
  $etcdctl --username root:$ROOT_PASSWORD role get $role
    <% end %>
  <% end %>
  <% end %>

  turn_on_authentication

}

turn_on_authentication() {
  ## in case it's already enabled
  ## enable in the end in case before role is granted user don't have acceess
  set +e
  result=$($etcdctl --username root:$ROOT_PASSWORD auth enable 2>&1)
  status=$?
  set -e
  if [ "$status" -ne 0 ]; then
    enable_auth_duplicate_regex="auth: already enabled"
    if ! [[ "$result" =~ $enable_auth_duplicate_regex ]]; then
      echo "Error enable auth: $result"
      exit 1
    fi
  fi
}

main() {
  timeout 120 /var/vcap/jobs/etcd/bin/ensure-member-healthy
  update_peer_url_to_correct_dns_address
  setup_users_auth
}

main $@
